1. Roles Identified:

Admin: System oversight (inferred from generic RBAC requirements).
Landlord: Property owner. Can publish listings, manage applications, and verify ownership.
Agent: Professional intermediary. Can publish listings, manage applications, and requires agency verification (license).
Tenant (Student): End-user. Can search properties, apply, report issues, and manage favorites.
2. Key Data Entities & API Usage:

Properties:
Read: Publicly accessible (with detailed fields like bathroom, amenities, location).
Create/Update: Restricted to Landlord and Agent.
Fields: title, price, address, features, verification_documents (proof of ownership for landlords), etc.
Applications:
Read: Tenant (own applications) and Landlord/Agent (incoming applications for their properties).
Action: Tenant can create. Landlord/Agent can update status (accept/reject).
Fields: applicant_details, message, files (student ID, transcript), status.
User Profiles:
Read/Write: Users manage their own profile.
Fields: role, student_id (for tenants), agency_license (for agents).
Complaints/Reports:
Create: Accessible to all authenticated users.
Read: Admin only.



Revised Database Schema for Supabase
1. public.profiles
User profile extension with field-level RLS

sql
CREATE TABLE public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role text NOT NULL CHECK (role IN ('admin', 'landlord', 'agent', 'tenant')),
  full_name text NOT NULL,
  avatar_url text,
  phone text,
  
  -- Private fields (tenant-specific)
  student_id text,
  
  -- Private fields (agent-specific)
  agency_name text,
  agency_license text,
  
  -- Verification status
  is_verified boolean DEFAULT false,
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- RLS Policies (field-level control)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
-- Public can read basic fields only
CREATE POLICY "Public profiles are viewable by everyone"
  ON public.profiles FOR SELECT
  USING (true);
-- Users can update their own profile
CREATE POLICY "Users can update own profile"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id);
-- Admin can see all fields (handled via separate admin policies)
CREATE POLICY "Admin full access"
  ON public.profiles FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin'
    )
  );
Column Visibility (via Application Logic):

Public fields: 
id
, role, full_name, avatar_url, is_verified
Private to owner: phone, student_id, agency_name, agency_license
Admin only: All fields
2. public.properties
Property listings with user-specified structure

sql
CREATE TABLE public.properties (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Basic info
  title text NOT NULL,
  description text,
  price numeric NOT NULL CHECK (price >= 0),
  address text NOT NULL,
  category text CHECK (category IN ('Studio', 'Apartment', 'Condo', 'Terrace', 'Bungalow', 'Room')),
  
  -- Specifications
  beds integer NOT NULL CHECK (beds > 0),
  bathrooms integer CHECK (bathrooms >= 0),
  kitchen boolean DEFAULT false,
  size_sqm numeric CHECK (size_sqm > 0),
  
  -- Additional metadata
  furnished text CHECK (furnished IN ('full', 'half', 'none')),
  amenities text[], -- Array: ['Wi-Fi', 'Pool', 'Gym']
  available_from date,
  
  -- Geolocation (optional for map features)
  latitude numeric,
  longitude numeric,
  
  -- Status
  status text DEFAULT 'active' CHECK (status IN ('active', 'rented', 'delisted')),
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
CREATE INDEX idx_properties_owner ON public.properties(owner_id);
CREATE INDEX idx_properties_status ON public.properties(status);
-- RLS Policies
ALTER TABLE public.properties ENABLE ROW LEVEL SECURITY;
-- Everyone can view active properties
CREATE POLICY "Active properties are publicly viewable"
  ON public.properties FOR SELECT
  USING (status = 'active' OR auth.uid() = owner_id);
-- Only landlords/agents can create properties
CREATE POLICY "Verified landlords/agents can create properties"
  ON public.properties FOR INSERT
  WITH CHECK (
    auth.uid() = owner_id AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() 
      AND role IN ('landlord', 'agent')
      AND is_verified = true
    )
  );
-- Owners can update their own properties
CREATE POLICY "Owners can update own properties"
  ON public.properties FOR UPDATE
  USING (auth.uid() = owner_id);
-- Owners can delete their own properties
CREATE POLICY "Owners can delete own properties"
  ON public.properties FOR DELETE
  USING (auth.uid() = owner_id);
3. public.property_images
Separate table for property images

sql
CREATE TABLE public.property_images (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id uuid NOT NULL REFERENCES public.properties(id) ON DELETE CASCADE,
  image_url text NOT NULL,
  is_cover boolean DEFAULT false,
  order_index integer DEFAULT 0,
  
  created_at timestamptz DEFAULT now()
);
CREATE INDEX idx_property_images_property ON public.property_images(property_id);
CREATE INDEX idx_property_images_cover ON public.property_images(property_id, is_cover);
-- RLS Policies
ALTER TABLE public.property_images ENABLE ROW LEVEL SECURITY;
-- Public read access
CREATE POLICY "Property images are publicly viewable"
  ON public.property_images FOR SELECT
  USING (true);
-- Only property owner can manage images
CREATE POLICY "Property owners can manage images"
  ON public.property_images FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.properties
      WHERE id = property_id AND owner_id = auth.uid()
    )
  );
4. public.applications
Tenant applications with redundant owner_id for RLS

sql
CREATE TABLE public.applications (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id uuid NOT NULL REFERENCES public.properties(id) ON DELETE CASCADE,
  applicant_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Redundant for RLS (denormalized from properties.owner_id)
  property_owner_id uuid NOT NULL REFERENCES public.profiles(id),
  
  message text,
  documents jsonb, -- [{ name: 'id.jpg', url: '...' }]
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected')),
  
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  
  UNIQUE(property_id, applicant_id) -- Prevent duplicate applications
);
CREATE INDEX idx_applications_property ON public.applications(property_id);
CREATE INDEX idx_applications_applicant ON public.applications(applicant_id);
CREATE INDEX idx_applications_owner ON public.applications(property_owner_id);
-- RLS Policies
ALTER TABLE public.applications ENABLE ROW LEVEL SECURITY;
-- Applicants can view their own applications
CREATE POLICY "Applicants can view own applications"
  ON public.applications FOR SELECT
  USING (auth.uid() = applicant_id);
-- Property owners can view applications for their properties
CREATE POLICY "Property owners can view received applications"
  ON public.applications FOR SELECT
  USING (auth.uid() = property_owner_id);
-- Tenants can submit applications
CREATE POLICY "Tenants can submit applications"
  ON public.applications FOR INSERT
  WITH CHECK (
    auth.uid() = applicant_id AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role = 'tenant'
    )
  );
-- Property owners can update application status
CREATE POLICY "Property owners can update application status"
  ON public.applications FOR UPDATE
  USING (auth.uid() = property_owner_id)
  WITH CHECK (auth.uid() = property_owner_id);
Trigger to auto-populate property_owner_id:

sql
CREATE OR REPLACE FUNCTION set_application_owner()
RETURNS TRIGGER AS $$
BEGIN
  SELECT owner_id INTO NEW.property_owner_id
  FROM public.properties
  WHERE id = NEW.property_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE TRIGGER trg_set_application_owner
  BEFORE INSERT ON public.applications
  FOR EACH ROW
  EXECUTE FUNCTION set_application_owner();
5. public.favorites
User bookmarks (ALL roles can use)

sql
CREATE TABLE public.favorites (
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  property_id uuid NOT NULL REFERENCES public.properties(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now(),
  
  PRIMARY KEY (user_id, property_id)
);
CREATE INDEX idx_favorites_user ON public.favorites(user_id);
-- RLS Policies
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
-- Users can only see their own favorites
CREATE POLICY "Users can view own favorites"
  ON public.favorites FOR SELECT
  USING (auth.uid() = user_id);
-- Users can add/remove favorites
CREATE POLICY "Users can manage own favorites"
  ON public.favorites FOR INSERT
  WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete own favorites"
  ON public.favorites FOR DELETE
  USING (auth.uid() = user_id);
6. public.complaints
Reports with polymorphic reference (fixed)

sql
CREATE TABLE public.complaints (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  reporter_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Polymorphic reference
  target_type text NOT NULL CHECK (target_type IN ('property', 'user')),
  target_id uuid NOT NULL,
  
  category text NOT NULL CHECK (category IN ('Fraud / Scam', 'False Information', 'Unresponsive', 'Harassment', 'Other')),
  description text NOT NULL,
  status text DEFAULT 'open' CHECK (status IN ('open', 'investigating', 'resolved', 'dismissed')),
  admin_notes text,
  
  created_at timestamptz DEFAULT now(),
  resolved_at timestamptz
);
CREATE INDEX idx_complaints_target ON public.complaints(target_type, target_id);
CREATE INDEX idx_complaints_status ON public.complaints(status);
-- RLS Policies
ALTER TABLE public.complaints ENABLE ROW LEVEL SECURITY;
-- Users can submit complaints
CREATE POLICY "Users can submit complaints"
  ON public.complaints FOR INSERT
  WITH CHECK (auth.uid() = reporter_id);
-- Only admins can view/manage complaints
CREATE POLICY "Admins can manage complaints"
  ON public.complaints FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );
7. public.verification_requests
Separate table for landlord/agent verification

sql
CREATE TABLE public.verification_requests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  request_type text NOT NULL CHECK (request_type IN ('landlord_ownership', 'agent_license')),
  
  -- Document storage
  documents jsonb NOT NULL, -- [{ type: 'license', url: '...' }]
  
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
  admin_notes text,
  reviewed_by uuid REFERENCES public.profiles(id),
  reviewed_at timestamptz,
  
  created_at timestamptz DEFAULT now(),
  
  UNIQUE(user_id, request_type) -- One active request per type
);
CREATE INDEX idx_verification_status ON public.verification_requests(status);
-- RLS Policies
ALTER TABLE public.verification_requests ENABLE ROW LEVEL SECURITY;
-- Users can submit verification requests
CREATE POLICY "Users can submit verification requests"
  ON public.verification_requests FOR INSERT
  WITH CHECK (auth.uid() = user_id);
-- Users can view their own requests
CREATE POLICY "Users can view own verification requests"
  ON public.verification_requests FOR SELECT
  USING (auth.uid() = user_id);
-- Admins can manage verification requests
CREATE POLICY "Admins can manage verifications"
  ON public.verification_requests FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );
